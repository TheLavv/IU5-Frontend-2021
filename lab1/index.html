<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="D:/home/IU5-Frontend-2021/lab1/style.css">
    <title>NGINX изнутри</title>
    <style>
        #info {
            color: gray;
            font-style: italic;
        }
    </style>
</head>

<body class="body_format">
    <p style="text-align: right;">
        <b>Логин:</b><br>
        <select size="1">
            <option disabled>Выберите логин</option>
            <option>admin</option>
            <option>user</option>
        </select><br>
        <b>Email:</b><br>
        <input type="text" size="25"><br>
        <b>Пароль:</b><br>
        <input type="password" size="25"><br><br>
        <input type="submit" value="Отправить">
        <input type="reset" value="Очистить">
    </p>
    <h1 class="article_title">
        NGINX изнутри: рожден для производительности и масштабирования
    </h1>
    <div>
        <a href="http://cdn.nginx.com/wp-content/uploads/2015/04/150427_NGINX-subway_RGB.png">
            <img src="https://habrastorage.org/files/ead/3f0/718/ead3f0718b0347099a7d55a7091bbc87.png" height="150" align="left" hspace="50" alt="NGINX architecture">
        </a>
        <p style="color:rgb(60, 2, 107)">
            NGINX вполне заслуженно является одним из <span class="important">лучших</span> по производительности серверов, и всё это благодаря его внутреннему устройству.
            <br><br>В то время, как многие веб-серверы и серверы приложений используют простую многопоточную модель, NGINX выделяется из общей массы своей нетривиальной событийной архитектурой, которая позволяет ему с легкостью масштабироваться до сотен
            тысяч параллельных соединений.
            <br><br>Инфографика
            <a href="http://nginx.com/resources/library/infographic-inside-nginx/">Inside NGINX</a> сверху вниз проведет вас по азам устройства процессов к иллюстрации того, как NGINX обрабатывает множество соединений в одном процессе. Данная статья рассмотрит
            всё это чуть более детально.
        </p>
    </div>
    <hr>
    <h2 class="article_title">
        Модель NGINX процессов
    </h2>
    <div>
        <p>
            <img src="https://habrastorage.org/getpro/habr/post_images/301/4dd/b52/3014ddb5204804c1e7f92c7de673ed35.png" width="40%" alt="master process" hspace="50" align="left"> Чтобы лучше представлять устройство, сперва необходимо понять как NGINX
            запускается.
            <br>У NGINX есть один <span class="important">мастер-процесс</span> (который от имени суперпользователя выполняет такие операции, как чтение конфигурации и открытие портов), а также некоторое количество рабочих и вспомогательных процессов.
            <img src="D:/home/IU5-Frontend-2021/lab1/images/nginx_processes.png" alt="nginx processes" align="bottom" width="30%" vspace="30">
            <br>На 4-х ядерном сервере мастер-процесс NGINX создает 4 рабочих процесса и пару вспомогательных кэш-процессов, которые управляют содержимым кэша на жестком диске.
        </p>
    </div>
    <h2 class="article_title">
        Почему архитектура всё же важна?
    </h2>
    <div>
        <p class="default_text">
            Одна из фундаментальных основ любого Unix-приложения — это процесс или поток (с точки зрения ядра Linux процессы и потоки практически одно и то же — вся разница в разделении адресного пространства). Процесс или поток — это самодостаточный набор инструкций,
            который операционная система может запланировать для выполнения на ядре процессора. Большинство сложных приложений параллельно запускают множество процессов или потоков по двум причинам:
        </p>
        <ul>
            <li>Чтобы одновременно задействовать больше вычислительных ядер;</li>
            <li>Процессы и потоки позволяют проще выполнять параллельные операции (например обрабатывать множество соединений одновременно).</li>
        </ul>
        <p class="default_text">
            Процессы и потоки сами по себе расходуют дополнительные ресурсы. Каждый такой процесс или поток потребляет некоторое количество памяти, а кроме того они постоянно подменяют друг друга на процессоре (т. н. переключение контекста). Современные серверы могут
            справляться с сотнями активных процессов и потоков, но производительность сильно страдает, как только заканчивается память или огромное количество операций ввода-вывода приводит к слишком частой смене контекста.
            <br><br>Наиболее типичный подход к построению сетевого приложения — это выделять для каждого соединения отдельный процесс или поток. Такая архитектура проста для понимания и легка в реализации, но при этом плохо масштабируется когда приложению
            приходится работать с тысячами соединений одновременно.
        </p>
    </div>
    <h2 class="article_title">
        Как же работает NGINX?
    </h2>
    <div>
        <p class="default_text">
            NGINX использует модель с фиксированным числом процессов, которая наиболее эффективно задействует доступные ресурсы системы:
        </p>
        <table border="1">
            <tr>
                <td>Единственный мастер-процесс выполняет операции, которые требуют повышенных прав, такие, как чтение конфигурации и открытие портов, а затем порождает небольшое число дочерних процессов (следующие три типа).</td>
            </tr>
            <tr>
                <td>Загрузчик кэша запускается на старте чтобы загрузить данные кэша, расположенные на диске, в оперативную память, а затем завершается. Его работа спланирована так, чтобы не потреблять много ресурсов.</td>
            </tr>
            <tr>
                <td>Кэш-менеджер просыпается периодически и удаляет объекты кэша с жесткого диска, чтобы поддерживать его объем в рамках заданного ограничения.</td>
            </tr>
            <tr>
                <td>Рабочие процессы выполняют всю работу. Они обрабатывают сетевые соединения, читают данные с диска и пишут на диск, общаются с бэкенд-серверами.</td>
            </tr>
        </table>
        <p class="default_text">
            Документация NGINX рекомендует в большинстве случаев настраивать число рабочих процессов равное количеству ядер процессора, что позволяет использовать системные ресурсы максимально эффективно. Вы можете задать такой режим с помощью директивы
            <a href="http://nginx.org/ru/docs/ngx_core_module.html#worker_processes">worker_processes auto</a> в конфигурационном файле:
            <code style="padding-left: 10px">
                <span style="color:green">worker_processes</span> auto;
            </code>
            <br><br> Когда NGINX находится под нагрузкой, то в основном заняты рабочие процессы. Каждый из них обрабатывает множество соединений в неблокирующемся режиме, минимизируя количество переключений контекста. Каждый рабочий процесс однопоточен
            и работает независимо, принимая новые соединения и обрабатывая их. Процессы взаимодействуют друг с другом используя разделяемую память для данных кэша, сессий и других общих ресурсов.
        </p>
    </div>
    <h2 class="article_title">
        Внутри рабочего процесса
    </h2>
    <div>
        <img src="https://habrastorage.org/getpro/habr/post_images/919/93e/edf/91993eedfc1d6917012144309c5f5422.png" alt="work process" width="60%">
        <p class="default_text">
            Каждый рабочий процесс NGINX инициализируется с заданной конфигурацией и набором слушающих сокетов, унаследованных от мастер-процесса.
            <br><br>Рабочие процессы начинают с ожидания событий на слушающих сокетах (см. также accept_mutex и разделяемые сокеты). События извещают о новых соединениях. Эти соединения попадают в конечный автомат — наиболее часто используемый предназначен
            для обработки HTTP, но NGINX также содержит конечные автоматы для обработки потоков TCP трафика (модуль stream) и целого ряда протоколов электронной почты (SMTP, IMAP и POP3).
        </p>
        <img src="https://habrastorage.org/getpro/habr/post_images/d67/b17/488/d67b174884f49b2334903b3c0c78c90c.png" alt="work process" width="50%">
        <p class="default_text">
            Конечный автомат в NGINX по своей сути является набором инструкций для обработки запроса. Большинство веб-серверов выполняют такую же функцию, но разница кроется в реализации.
        </p>
    </div>
    <h2 class="article_title">
        Устройство конечного автомата
    </h2>
    <div>
        <p class="default_text">
            Конечный автомат можно представить себе в виде правил для игры в шахматы. Каждая HTTP транзакция — это шахматная партия. С одной стороны шахматной доски веб-сервер — гроссмейстер, который принимает решения очень быстро. На другой стороне — удаленный клиент,
            браузер, который запрашивает сайт или приложение по относительно медленной сети.
            <br><br>Как бы то ни было, правила игры могут быть очень сложными. Например, веб-серверу может потребоваться взаимодействовать с другими ресурсами (проксировать запросы на бэкенд) или обращаться к серверу аутентификации. Сторонние модули способны
            ещё сильнее усложнить обработку.
        </p>
    </div>
    <h2 class="article_title">
        Блокирующийся конечный автомат
    </h2>
    <div>
        <p class="default_text">
            Вспомните наше определение процесса или потока, как самодостаточного набора инструкций, выполнение которых операционная система может назначать на конкретное ядро процессора. Большинство веб-серверов и веб-приложений используют модель, в которой для «игры
            в шахматы» приходится по одному процессу или потоку на соединение. Каждый процесс или поток содержит инструкции, чтобы сыграть одну партию до конца. Все это время процесс, выполняясь на сервере, проводит большую часть времени заблокированным
            в ожидании следующего хода от клиента.
        </p>
        <p style="text-align: center;">
            <img src="https://habrastorage.org/getpro/habr/post_images/003/f31/fef/003f31feffc7feda66c4babe562596c8.png" width="25%">
        </p>
        <ol>
            <li>Процесс веб-сервера ожидает новых соединений (новых партий инициированных клиентами) на слушающих сокетах.</li>
            <li>Получив новое соединение, он играет партию, блокируясь после каждого хода в ожидании ответа от клиента.</li>
            <li>Когда партия сыграна, процесс веб-сервера может находиться в ожидании желания клиента начать следующую партию (это соответствует долгоживущим keepalive-соединениям). Если соединение закрыто (клиент ушел или наступил таймаут), процесс возвращается
                к встрече новых клиентов на слушающих сокетах.
            </li>
        </ol>
        <p class="default_text">
            Важный момент, который стоит отметить, заключается в том, что каждое активное HTTP-соединение (каждая партия) требует отдельного процесса или потока (гроссмейстера). Такая архитектура проста и легко расширяема с помощью сторонних модулей (новых «правил»).
            Однако, в ней существует огромный дисбаланс: достаточно легкое HTTP-соединение, представленное в виде файлового дескриптора и небольшого объема памяти, соотносится с отдельным процессом или потоком, достаточно тяжелым объектом в операционной
            системе. Это удобно для программирования, но весьма расточительно.
        </p>
    </div>
    <h2 class="article_title">
        NGINX, как настоящий Гроссмейстер
    </h2>
    <div>
        <p class="default_text">
            Вероятно вы слышали о сеансах одновременной игры, когда один гроссмейстер играет на множестве шахматных полей сразу с десятками противников?
        </p>
        <img src="https://habrastorage.org/getpro/habr/post_images/6e8/432/334/6e84323349febbc3ac141bdb003dba41.gif" width="30%">
        <p class="default_text">
            <span id="info">Кирил Георгиев на турнире в Болгарии сыграл параллельно 360 партий. Его итоговый результат составил: 284 победы, 70 вничью и 6 поражений.</span>
            <br><br>Таким же образом рабочий процесс NGINX «играет в шахматы». Каждый рабочий процесс (помните — обычно всего один на вычислительное ядро) является гроссмейстером, способным играть сотни (а на самом деле сотни тысяч) партий одновременно.
        </p>
        <p style="text-align: center;">
            <img src="https://habrastorage.org/getpro/habr/post_images/2ef/5bc/252/2ef5bc252c8ec88f51fed4f4d0b0eda0.png" width="25%">
        </p>
        <ol>
            <li>Рабочий процесс ожидает событий на слушающих сокетах и сокетах соединений.</li>
            <li>На сокетах происходят события и процесс их обрабатывает:
                <br>
                <br>
                <ul>
                    <li>Событие на слушающем сокете означает, что пришел новый клиент для начала игры. Рабочий процесс создает новый сокет соединения.</li>
                    <li>Событие на сокете соединений сигнализирует, что клиент сделал ход. Рабочий процесс ему мгновенно отвечает.</li>
                </ul>
            </li>
        </ol>
        <p class="default_text">
            Рабочий процесс, обрабатывая сетевой трафик, никогда не блокируется, ожидая очередного хода от оппонента (клиента). После того как процесс сделал свой ход, он немедленно переходит к другим доскам, на которых игроки ожидают хода, или встречает новых у
            двери
        </p>
    </div>
    <h2 class="article_title">
        Почему так получается быстрее, чем блокирующаяся многопоточная архитектура?
    </h2>
    <div>
        <p class="default_text">
            Каждое новое соединение создает файловый дескриптор и потребляет небольшой объем памяти в рабочем процессе. Это очень малые накладные расходы на соединение. Процессы NGINX могут оставаться привязанными к конкретным ядрам процессора. Переключения контекста
            происходят достаточно редко и в основном когда не осталось больше работы.
            <br><br>В блокирующемся подходе, с отдельным процессом на каждое соединение, требуется сравнительно большой объем дополнительных ресурсов, и переключения контекста с одного процесса на другой происходят гораздо чаще.
            <br><br>Дополнительную информацию по теме можно также узнать из
            <a href="http://www.aosabook.org/en/nginx.html">статьи об архитектуре NGINX</a> от Андрея Алексеева, вице-президента по развитию и сооснователя компании NGINX, Inc. С адекватной настройкой системы, NGINX прекрасно масштабируется до многих
            сотен тысяч параллельных HTTP cоединений на каждый рабочий процесс и уверенно поглощает всплески трафика (толпы новых игроков).
        </p>
    </div>
    <h2 class="article_title">
        Обновление конфигурации и исполняемого кода
    </h2>
    <div>
        <p class="default_text">
            Архитектура NGINX с малым количеством рабочих процессов позволяет достаточно эффективно обновлять конфигурацию и даже его собственный исполняемый код на лету.
        </p>
        <img src="https://habrastorage.org/getpro/habr/post_images/2f4/fba/5bd/2f4fba5bd78bd428935dec150447e5ec.png" alt="pic" width="50%">
        <p class="default_text">
            Обновление конфигурации NGINX — очень простая, легковесная и надежная процедура. Она заключается в простой отправке мастер-процессу сигнала SIGHUP.
            <br><br>Когда рабочий процесс получает SIGHUP, он производит несколько операций:
        </p>
        <ol>
            <li>
                Перезагружает конфигурацию и порождает новый набор рабочих процессов. Эти новые рабочие процессы сразу начинают принимать соединения и обрабатывать трафик (используя новые настройки).
            </li>
            <li>
                Сигнализирует старые рабочие процессы о плавном завершении. Они перестают принимать новые соединения. Как только завершается обработка текущих HTTP-запросов, соединения закрываются (никаких затянувшихся keep-alive соединений). Как только все соединения
                закрыты, рабочий процесс завершается.
            </li>
        </ol>
        <p class="default_text">
            Данная процедура может вызвать небольшой всплеск нагрузки на процессор и память, но в общем это практически незаметно на фоне затрат на обработку активных соединений. Вы можете перезагружать конфигурацию несколько раз в секунду (и есть немало пользователей
            NGINX, кто так делает). В редких случаях могут возникнуть проблемы, когда слишком много поколений рабочих процессов NGINX ожидают закрытия соединений, но они быстро разрешаются.
            <br><br>Обновление исполняемого кода NGINX — это Святой Грааль высокой доступности сервисов. Вы можете обновлять сервер на лету, без потери соединений, простоя ресурсов и каких-либо перерывов в обслуживании клиентов.
        </p>
        <img src="https://habrastorage.org/getpro/habr/post_images/86c/42a/f29/86c42af293b400cb4872b6f9b0d9e23d.png" alt="pic" width="50%">
        <p class="default_text">
            Процесс обновления исполняемого кода использует схожий с перезагрузкой конфигурации подход. Новый мастер-процесс NGINX запускается параллельно со старым и получает от него дескрипторы слушающих сокетов. Оба процесса загружены и их рабочие процессы обрабатывают
            трафик. Затем вы можете отдать команду старому мастер-процессу на плавное завершение.
            <br><br>Вся процедура подробно описана в
            <a href="http://nginx.org/ru/docs/control.html#upgrade">документации</a>.
        </p>
    </div>
    <h2 class="article_title">
        Подведем итоги
    </h2>
    <div>
        <p class="default_text" style="max-width: 300px; max-height: 300px;">
            <sup>Мы дали поверхностный обзор того, как функционирует NGINX</sup>. <sub>Под этими простыми описаниями скрывается более чем десятилетний опыт разработки и оптимизации, который позволяет NGINX демонстрировать выдающуюся производительность на широком спектре оборудования
            и реальных задачах, оставаясь надежным и безопасным, как того требуют современные веб-приложения</sub>.
        </p>
    </div>
</body>

</html>